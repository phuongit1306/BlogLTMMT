<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bài 10 - Xử lý Bất đồng bộ trong JavaScript – Hiểu rõ Callback, Promise và Async/Await | Blog Lập Trình - 2180607911 - Nguyễn Thanh Phương - 21DTHD3</title><meta name=keywords content="JavaScript,Lập trình web,Bất đồng bộ,Async Await"><meta name=description content="
JavaScript là ngôn ngữ đơn luồng (single-threaded), nghĩa là nó chỉ thực hiện một tác vụ tại một thời điểm.
Vậy làm sao JavaScript có thể xử lý được những tác vụ mất thời gian như tải dữ liệu từ server, đọc file, hay đợi người dùng thao tác mà không làm treo trình duyệt?

👉 Câu trả lời nằm ở cơ chế xử lý bất đồng bộ (asynchronous programming)."><meta name=author content="Nguyễn Thanh Phương"><link rel=canonical href=https://phuongit1306.github.io/BlogLTMMT/blog/bai10-xu-ly-bat-dong-bo-trong-javascript/><link crossorigin=anonymous href=/BlogLTMMT/assets/css/stylesheet.f667fa849b311bd163850c3378050960a71d10c762f52871057d18ac68622e2f.css integrity="sha256-9mf6hJsxG9FjhQwzeAUJYKcdEMdi9ShxBX0YrGhiLi8=" rel="preload stylesheet" as=style><link rel=icon href=https://phuongit1306.github.io/BlogLTMMT/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://phuongit1306.github.io/BlogLTMMT/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://phuongit1306.github.io/BlogLTMMT/favicon-32x32.png><link rel=apple-touch-icon href=https://phuongit1306.github.io/BlogLTMMT/apple-touch-icon.png><link rel=mask-icon href=https://phuongit1306.github.io/BlogLTMMT/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://phuongit1306.github.io/BlogLTMMT/blog/bai10-xu-ly-bat-dong-bo-trong-javascript/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://phuongit1306.github.io/BlogLTMMT/blog/bai10-xu-ly-bat-dong-bo-trong-javascript/"><meta property="og:site_name" content="Blog Lập Trình - 2180607911 - Nguyễn Thanh Phương - 21DTHD3"><meta property="og:title" content="Bài 10 - Xử lý Bất đồng bộ trong JavaScript – Hiểu rõ Callback, Promise và Async/Await"><meta property="og:description" content=" JavaScript là ngôn ngữ đơn luồng (single-threaded), nghĩa là nó chỉ thực hiện một tác vụ tại một thời điểm. Vậy làm sao JavaScript có thể xử lý được những tác vụ mất thời gian như tải dữ liệu từ server, đọc file, hay đợi người dùng thao tác mà không làm treo trình duyệt? 👉 Câu trả lời nằm ở cơ chế xử lý bất đồng bộ (asynchronous programming)."><meta property="og:locale" content="vi"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-10-30T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-30T00:00:00+00:00"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="Lập Trình Web"><meta property="article:tag" content="Bất Đồng Bộ"><meta property="article:tag" content="Async Await"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bài 10 - Xử lý Bất đồng bộ trong JavaScript – Hiểu rõ Callback, Promise và Async/Await"><meta name=twitter:description content="
JavaScript là ngôn ngữ đơn luồng (single-threaded), nghĩa là nó chỉ thực hiện một tác vụ tại một thời điểm.
Vậy làm sao JavaScript có thể xử lý được những tác vụ mất thời gian như tải dữ liệu từ server, đọc file, hay đợi người dùng thao tác mà không làm treo trình duyệt?

👉 Câu trả lời nằm ở cơ chế xử lý bất đồng bộ (asynchronous programming)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog - Lập trình mạng máy tính","item":"https://phuongit1306.github.io/BlogLTMMT/blog/"},{"@type":"ListItem","position":2,"name":"Bài 10 - Xử lý Bất đồng bộ trong JavaScript – Hiểu rõ Callback, Promise và Async/Await","item":"https://phuongit1306.github.io/BlogLTMMT/blog/bai10-xu-ly-bat-dong-bo-trong-javascript/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bài 10 - Xử lý Bất đồng bộ trong JavaScript – Hiểu rõ Callback, Promise và Async/Await","name":"Bài 10 - Xử lý Bất đồng bộ trong JavaScript – Hiểu rõ Callback, Promise và Async\/Await","description":" JavaScript là ngôn ngữ đơn luồng (single-threaded), nghĩa là nó chỉ thực hiện một tác vụ tại một thời điểm. Vậy làm sao JavaScript có thể xử lý được những tác vụ mất thời gian như tải dữ liệu từ server, đọc file, hay đợi người dùng thao tác mà không làm treo trình duyệt? 👉 Câu trả lời nằm ở cơ chế xử lý bất đồng bộ (asynchronous programming).\n","keywords":["JavaScript","Lập trình web","Bất đồng bộ","Async Await"],"articleBody":" JavaScript là ngôn ngữ đơn luồng (single-threaded), nghĩa là nó chỉ thực hiện một tác vụ tại một thời điểm. Vậy làm sao JavaScript có thể xử lý được những tác vụ mất thời gian như tải dữ liệu từ server, đọc file, hay đợi người dùng thao tác mà không làm treo trình duyệt? 👉 Câu trả lời nằm ở cơ chế xử lý bất đồng bộ (asynchronous programming).\n⚙️ 1. Cơ chế Event Loop Khi chạy JavaScript, các tác vụ được đưa vào Call Stack, và các công việc bất đồng bộ (như setTimeout, fetch, hay event listener) sẽ được Web APIs xử lý, sau đó đẩy về Callback Queue khi hoàn tất. Event Loop liên tục kiểm tra xem Stack có rảnh không để đẩy callback vào thực thi. 📸 Minh họa cơ chế Event Loop: 🧩 2. Callback – Cách cổ điển để xử lý bất đồng bộ console.log(\"Bắt đầu tải dữ liệu...\"); setTimeout(() =\u003e { console.log(\"✅ Dữ liệu đã được tải!\"); }, 2000); console.log(\"Đang chờ dữ liệu...\"); 🧠 Kết quả:\nBắt đầu tải dữ liệu... Đang chờ dữ liệu... ✅ Dữ liệu đã được tải! Callback giúp xử lý bất đồng bộ, nhưng nếu lồng nhiều callback sẽ dẫn đến callback hell.\n📉 Minh họa Callback Hell: 🚀 3. Promise – Giải pháp hiện đại hơn Promise đại diện cho một giá trị sẽ có trong tương lai (thành công hoặc thất bại).\nfunction fetchData() { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { resolve(\"✅ Dữ liệu tải thành công!\"); }, 2000); }); } console.log(\"Bắt đầu...\"); fetchData() .then((result) =\u003e console.log(result)) .catch((error) =\u003e console.error(\"Lỗi:\", error)) .finally(() =\u003e console.log(\"Hoàn tất\")); 🧩 Kết quả: Bắt đầu... ✅ Dữ liệu tải thành công! Hoàn tất ⏳ 4. Async / Await – Cú pháp hiện đại, dễ đọc async và await giúp viết code bất đồng bộ trông như đồng bộ, dễ hiểu và dễ debug hơn.\nasync function getData() { console.log(\"⏳ Đang tải...\"); const data = await new Promise((resolve) =\u003e setTimeout(() =\u003e resolve(\"✅ Tải xong dữ liệu!\"), 2000) ); console.log(data); } getData(); console.log(\"➡️ Hàm vẫn tiếp tục chạy...\"); Kết quả:\n⏳ Đang tải... ➡️ Hàm vẫn tiếp tục chạy... ✅ Tải xong dữ liệu! 🌐 5. Ví dụ thực tế: Gọi API từ Server async function getUserData() { try { const response = await fetch(\"https://jsonplaceholder.typicode.com/users/1\"); const user = await response.json(); console.log(\"👤 Tên người dùng:\", user.name); } catch (error) { console.error(\"⚠️ Lỗi:\", error); } } getUserData(); 🧠 6. So sánh 3 cách tiếp cận Cách Ưu điểm Nhược điểm Callback Dễ hiểu, cơ bản Gây “callback hell” Promise Dễ quản lý chuỗi công việc Cú pháp .then() hơi rườm rà Async/Await Đọc dễ như code đồng bộ Phải chạy trong hàm async ⚙️ 7. Một ví dụ kết hợp: Promise + Async/Await function downloadFile(fileName) { return new Promise((resolve) =\u003e { setTimeout(() =\u003e resolve(`📦 ${fileName} tải xong!`), 1500); }); } async function downloadAll() { const files = [\"data1.json\", \"data2.json\", \"data3.json\"]; for (const file of files) { const msg = await downloadFile(file); console.log(msg); } console.log(\"🎉 Tất cả file đã tải hoàn tất!\"); } downloadAll(); 💡 8. Tổng kết Callback là nền tảng cho mọi cơ chế bất đồng bộ.\nPromise giúp code gọn gàng hơn.\nAsync/Await mang lại trải nghiệm gần như lập trình đồng bộ.\nLuôn sử dụng try…catch trong async để xử lý lỗi.\n🧭 9. Ứng dụng trong thực tế Ứng dụng Mô tả 🌐 Gọi API Lấy dữ liệu từ backend 🎮 Game online Chờ dữ liệu từ server hoặc đối thủ 📷 Ứng dụng camera Chờ phản hồi từ thiết bị 📦 Tải dữ liệu lớn Quản lý tiến trình tải file ✍️ Tác giả: Nguyễn Thanh Phương\n📅 Cập nhật: October 20, 2025\n","wordCount":"618","inLanguage":"en","datePublished":"2025-10-30T00:00:00Z","dateModified":"2025-10-30T00:00:00Z","author":{"@type":"Person","name":"Nguyễn Thanh Phương"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://phuongit1306.github.io/BlogLTMMT/blog/bai10-xu-ly-bat-dong-bo-trong-javascript/"},"publisher":{"@type":"Organization","name":"Blog Lập Trình - 2180607911 - Nguyễn Thanh Phương - 21DTHD3","logo":{"@type":"ImageObject","url":"https://phuongit1306.github.io/BlogLTMMT/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://phuongit1306.github.io/BlogLTMMT/ accesskey=h title="Blog Lập Trình - 2180607911 - Nguyễn Thanh Phương - 21DTHD3 (Alt + H)">Blog Lập Trình - 2180607911 - Nguyễn Thanh Phương - 21DTHD3</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://phuongit1306.github.io/BlogLTMMT/ title=Home><span>Home</span></a></li><li><a href=https://phuongit1306.github.io/BlogLTMMT/blog title=📝><span>📝</span></a></li><li><a href=https://phuongit1306.github.io/BlogLTMMT/about title=📩><span>📩</span></a></li><li><a href=https://phuongit1306.github.io/BlogLTMMT/certificates title=🎓><span>🎓</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://phuongit1306.github.io/BlogLTMMT/>Home</a>&nbsp;»&nbsp;<a href=https://phuongit1306.github.io/BlogLTMMT/blog/>Blog - Lập trình mạng máy tính</a></div><h1 class="post-title entry-hint-parent">Bài 10 - Xử lý Bất đồng bộ trong JavaScript – Hiểu rõ Callback, Promise và Async/Await</h1><div class=post-meta><span title='2025-10-30 00:00:00 +0000 UTC'>October 30, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Nguyễn Thanh Phương</span></div></header><div class=post-content><ul><li>JavaScript là ngôn ngữ <strong>đơn luồng (single-threaded)</strong>, nghĩa là nó chỉ thực hiện <strong>một tác vụ tại một thời điểm</strong>.</li><li>Vậy làm sao JavaScript có thể xử lý được những tác vụ <strong>mất thời gian</strong> như tải dữ liệu từ server, đọc file, hay đợi người dùng thao tác mà <strong>không làm treo trình duyệt</strong>?</li></ul><p>👉 Câu trả lời nằm ở <strong>cơ chế xử lý bất đồng bộ (asynchronous programming)</strong>.</p><hr><h2 id=-1-cơ-chế-event-loop>⚙️ 1. Cơ chế Event Loop<a hidden class=anchor aria-hidden=true href=#-1-cơ-chế-event-loop>#</a></h2><ul><li>Khi chạy JavaScript, các tác vụ được đưa vào <strong>Call Stack</strong>, và các công việc bất đồng bộ (như <code>setTimeout</code>, <code>fetch</code>, hay <code>event listener</code>) sẽ được <strong>Web APIs</strong> xử lý, sau đó đẩy về <strong>Callback Queue</strong> khi hoàn tất.</li><li><strong>Event Loop</strong> liên tục kiểm tra xem Stack có rảnh không để đẩy callback vào thực thi.</li></ul><p>📸 <em>Minh họa cơ chế Event Loop:</em>
<img alt="Event Loop JavaScript" loading=lazy src=/images/js-event-loop.png></p><hr><h2 id=-2-callback--cách-cổ-điển-để-xử-lý-bất-đồng-bộ>🧩 2. Callback – Cách cổ điển để xử lý bất đồng bộ<a hidden class=anchor aria-hidden=true href=#-2-callback--cách-cổ-điển-để-xử-lý-bất-đồng-bộ>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Bắt đầu tải dữ liệu...&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setTimeout</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;✅ Dữ liệu đã được tải!&#34;</span>);
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>2000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Đang chờ dữ liệu...&#34;</span>);
</span></span></code></pre></div><p>🧠 Kết quả:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Bắt đầu tải dữ liệu...
</span></span><span style=display:flex><span>Đang chờ dữ liệu...
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>✅</span> Dữ liệu đã được tải<span style=color:#f92672>!</span>
</span></span></code></pre></div><blockquote><p>Callback giúp xử lý bất đồng bộ, nhưng nếu lồng nhiều callback sẽ dẫn đến callback hell.</p></blockquote><p>📉 Minh họa Callback Hell:
<img alt="Call back hell" loading=lazy src=/images/call-back-hell.png></p><hr><h2 id=-3-promise--giải-pháp-hiện-đại-hơn>🚀 3. Promise – Giải pháp hiện đại hơn<a hidden class=anchor aria-hidden=true href=#-3-promise--giải-pháp-hiện-đại-hơn>#</a></h2><p>Promise đại diện cho một giá trị sẽ có trong tương lai (thành công hoặc thất bại).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>function <span style=color:#a6e22e>fetchData</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((resolve, reject) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    setTimeout(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      resolve(<span style=color:#e6db74>&#34;✅ Dữ liệu tải thành công!&#34;</span>);
</span></span><span style=display:flex><span>    }, 2000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>console.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Bắt đầu...&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fetchData()
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>then</span>((result) <span style=color:#f92672>=&gt;</span> console.<span style=color:#a6e22e>log</span>(result))
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>catch</span>((error) <span style=color:#f92672>=&gt;</span> console.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Lỗi:&#34;</span>, error))
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>finally</span>(() <span style=color:#f92672>=&gt;</span> console.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Hoàn tất&#34;</span>));
</span></span></code></pre></div><h4 id=-kết-quả>🧩 Kết quả:<a hidden class=anchor aria-hidden=true href=#-kết-quả>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Bắt đầu...
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>✅</span> Dữ liệu tải thành công<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>Hoàn tất
</span></span></code></pre></div><hr><h2 id=-4-async--await--cú-pháp-hiện-đại-dễ-đọc>⏳ 4. Async / Await – Cú pháp hiện đại, dễ đọc<a hidden class=anchor aria-hidden=true href=#-4-async--await--cú-pháp-hiện-đại-dễ-đọc>#</a></h2><p>async và await giúp viết code bất đồng bộ trông như đồng bộ, dễ hiểu và dễ debug hơn.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>async function <span style=color:#a6e22e>getData</span>() {
</span></span><span style=display:flex><span>  console.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;⏳ Đang tải...&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> data <span style=color:#f92672>=</span> await <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Promise</span>((resolve) <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>    setTimeout(() <span style=color:#f92672>=&gt;</span> resolve(<span style=color:#e6db74>&#34;✅ Tải xong dữ liệu!&#34;</span>), 2000)
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>  console.<span style=color:#a6e22e>log</span>(data);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>getData();
</span></span><span style=display:flex><span>console.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;➡️ Hàm vẫn tiếp tục chạy...&#34;</span>);
</span></span></code></pre></div><p>Kết quả:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>⏳</span> Đang tải...
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>➡</span>️ Hàm vẫn tiếp tục chạy...
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>✅</span> Tải xong dữ liệu<span style=color:#f92672>!</span>
</span></span></code></pre></div><hr><h2 id=-5-ví-dụ-thực-tế-gọi-api-từ-server>🌐 5. Ví dụ thực tế: Gọi API từ Server<a hidden class=anchor aria-hidden=true href=#-5-ví-dụ-thực-tế-gọi-api-từ-server>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>async function <span style=color:#a6e22e>getUserData</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> response <span style=color:#f92672>=</span> await <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#34;https://jsonplaceholder.typicode.com/users/1&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> user <span style=color:#f92672>=</span> await response.<span style=color:#a6e22e>json</span>();
</span></span><span style=display:flex><span>    console.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;👤 Tên người dùng:&#34;</span>, user.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (error) {
</span></span><span style=display:flex><span>    console.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;⚠️ Lỗi:&#34;</span>, error);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>getUserData();
</span></span></code></pre></div><hr><h2 id=-6-so-sánh-3-cách-tiếp-cận>🧠 6. So sánh 3 cách tiếp cận<a hidden class=anchor aria-hidden=true href=#-6-so-sánh-3-cách-tiếp-cận>#</a></h2><table><thead><tr><th>Cách</th><th>Ưu điểm</th><th>Nhược điểm</th></tr></thead><tbody><tr><td><strong>Callback</strong></td><td>Dễ hiểu, cơ bản</td><td>Gây “callback hell”</td></tr><tr><td><strong>Promise</strong></td><td>Dễ quản lý chuỗi công việc</td><td>Cú pháp <code>.then()</code> hơi rườm rà</td></tr><tr><td><strong>Async/Await</strong></td><td>Đọc dễ như code đồng bộ</td><td>Phải chạy trong hàm <code>async</code></td></tr></tbody></table><hr><h2 id=-7-một-ví-dụ-kết-hợp-promise--asyncawait>⚙️ 7. Một ví dụ kết hợp: Promise + Async/Await<a hidden class=anchor aria-hidden=true href=#-7-một-ví-dụ-kết-hợp-promise--asyncawait>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>function <span style=color:#a6e22e>downloadFile</span>(fileName) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((resolve) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    setTimeout(() <span style=color:#f92672>=&gt;</span> resolve(<span style=color:#960050;background-color:#1e0010>`📦</span> ${fileName} tải xong<span style=color:#f92672>!</span><span style=color:#960050;background-color:#1e0010>`</span>), 1500);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>async function <span style=color:#a6e22e>downloadAll</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> files <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;data1.json&#34;</span>, <span style=color:#e6db74>&#34;data2.json&#34;</span>, <span style=color:#e6db74>&#34;data3.json&#34;</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> file of files) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> msg <span style=color:#f92672>=</span> await <span style=color:#a6e22e>downloadFile</span>(file);
</span></span><span style=display:flex><span>    console.<span style=color:#a6e22e>log</span>(msg);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  console.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;🎉 Tất cả file đã tải hoàn tất!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>downloadAll();
</span></span></code></pre></div><hr><h2 id=-8-tổng-kết>💡 8. Tổng kết<a hidden class=anchor aria-hidden=true href=#-8-tổng-kết>#</a></h2><ul><li><p>Callback là nền tảng cho mọi cơ chế bất đồng bộ.</p></li><li><p>Promise giúp code gọn gàng hơn.</p></li><li><p>Async/Await mang lại trải nghiệm gần như lập trình đồng bộ.</p></li><li><p>Luôn sử dụng try&mldr;catch trong async để xử lý lỗi.</p></li></ul><hr><h2 id=-9-ứng-dụng-trong-thực-tế>🧭 9. Ứng dụng trong thực tế<a hidden class=anchor aria-hidden=true href=#-9-ứng-dụng-trong-thực-tế>#</a></h2><table><thead><tr><th>Ứng dụng</th><th>Mô tả</th></tr></thead><tbody><tr><td>🌐 Gọi API</td><td>Lấy dữ liệu từ backend</td></tr><tr><td>🎮 Game online</td><td>Chờ dữ liệu từ server hoặc đối thủ</td></tr><tr><td>📷 Ứng dụng camera</td><td>Chờ phản hồi từ thiết bị</td></tr><tr><td>📦 Tải dữ liệu lớn</td><td>Quản lý tiến trình tải file</td></tr></tbody></table><hr><p>✍️ Tác giả: Nguyễn Thanh Phương</p><p>📅 Cập nhật: October 20, 2025</p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://phuongit1306.github.io/BlogLTMMT/tags/javascript/>JavaScript</a></li><li><a href=https://phuongit1306.github.io/BlogLTMMT/tags/l%E1%BA%ADp-tr%C3%ACnh-web/>Lập Trình Web</a></li><li><a href=https://phuongit1306.github.io/BlogLTMMT/tags/b%E1%BA%A5t-%C4%91%E1%BB%93ng-b%E1%BB%99/>Bất Đồng Bộ</a></li><li><a href=https://phuongit1306.github.io/BlogLTMMT/tags/async-await/>Async Await</a></li></ul><nav class=paginav><a class=next href=https://phuongit1306.github.io/BlogLTMMT/blog/bai9-lap-trinh-mang-voi-rmi-trong-java/><span class=title>Next »</span><br><span>Bài 9 - Lập trình mạng trong Java với RMI (Remote Method Invocation)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://phuongit1306.github.io/BlogLTMMT/>Blog Lập Trình - 2180607911 - Nguyễn Thanh Phương - 21DTHD3</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>